h1.docs-page-title Modals

section.docs-section
  a[href="#basics"]
    h2#basics Basics

  markdown:

    Modals are easy.  They require two chunks of markup to get up and running:

    {: .demo-list}
    * [A modal trigger](#creating-a-trigger)
    * [A modal body](#creating-a-body)

    If you aren't including the entirety of the Interfaces js, you'll need to require the `interfaces/interfaces.modals` package.

section.docs-section
  a[href="#creating-a-trigger"]
    h2#creating-a-trigger Creating a Trigger

  markdown:
    Interfaces uses a really nice data-attribute driven api to launch modals.

    You may trigger a modal by simply adding a `data-model-id` attribute with the id DOM node you are targeting.  For this example, let's target a modal with the id `#simpleModal`.

  =code_sample_static
    span data-modal-id="myModal" Launch #simpleModal

section.docs-section
  a[href="#creating-a-modal"]
    h2#creating-a-modal Creating a Modal

  markdown:
    The body of a modal is just as simple to implement.  Simply make a new div with class `.modal` and a unique id.

  =code_sample_static
    div.modal#myModal

  markdown:
    You may place this modal anywhere in the DOM.  The `data-api` takes care of moving it to the bottom of the DOM, when the time is right.



section.docs-section
  a[href="#composition"]
    h2#composition Body Composition

  markdown:
    Modals have a number of elements you can use to take advantage of default styles

  ruby:
    modal_data = {
      header: '<div class="modal-title"> Vizzini to the Man in Black </div>',
      body:   'You only think I guessed wrong! That\'s what\'s so funny! I switched glasses when your back was turned! Ha ha! You fool! You fell victim to one of the classic blunders - The most famous of which is "never get involved in a land war in Asia" - but only slightly less well-known is this: "Never go in against a Sicilian when death is on the line"! Ha ha ha ha ha ha ha! Ha ha ha ha ha ha ha! Ha ha ha...',
      footer: '<button class="btn btn--outline" type="button"> Walk away </button>'
    }

  .row:.col:pre.code-sample-static.language-markup:code
    = render_source 'interfaces/templates/modal'

  = render 'interfaces/templates/modal', mustache: modal_data

section.docs-section
  a[href="#closing-a-modal"]
    h2#closing-a-modal Closing a Modal

  markdown:
    Chances are, you're going to need to close these modals. We got you covered:

  =code_sample_static
    <span data-modal-close=""> Close! </span>

  markdown:
    You can hide the etire modal stage with a call to this JS global:

  .row:.col:pre.code-sample-static.language-javascript:code
    | INTERFACES.modalLayer.hide()

  markdown:
    There isn't currently a way to target a single modal, as there can only ever be one.  This may change.

section.docs-section
  a[href="#sizing"]
    h2#sizing Sizing

  markdown:
    Modals come in four widths:

  table.table
    tr
      td: code modal--small
      td: span 500px wide
    tr
      td: code modal--medium (default)
      td: span 600px wide
    tr
      td: code modal--large
      td: span 900px wide
    tr
      td: code modal--full
      td: span 95% width of application wrapper

section.docs-section
  a[href="#expectations"]
    h2#expectations Expectations and Gotchas

  markdown:
    Modals are intentionally simple.  There is a shocking lack of magic that happens.

    This is by design.  It's a high priority to keep the API maximally flexible, as we continue to develop apps in a array of disperate frontend technologies.  Here are the current expectations:

    ### *A Single Root*

    Modal templates should be composed with a single root element.  Modal content will not be massaged before being presented in the UI.

  .row:.col:pre.code-sample-static.language-markup:code
    = render_source 'interfaces/templates/modal_expectations'

  markdown:
    *While Interfaces wont correct templates, It will provide you with console errors when it encounters non-singular templates.*

  markdown:

    ### *Bring your own container*

    Your modal templates should have this as a minimum boilerplate:

  .row:.col:pre.code-sample-static.language-markup:code
    = render_source 'interfaces/templates/modal_boilerplate'

  markdown:
    This allows you the flexibilty to apply [sizing-modifiers](#sizing) directly on your template.

section.docs-section
  a[href="#modal-url"]
    h2#modal-url Modal for URL

  markdown:
    Modal dialogs can also be built from an external page in your application.  You can specify the page you'd like to load with like so:

  .row:.col:pre.code-sample-static.language-markup:code
    = render_source 'interfaces/templates/modal_url'

  markdown:
    Under the covers, Interfaces is going to `$.get()` the page at that URL and add it as a modal.

    This API is intentionally dumb.  It's not going to do much magic for you.  So, you will need to give your page all the [stylings required for any other modal](#composition).  As an example see, `test/dummy/public/sample_url_modal.html`.

    Additionally, be sure to read the [expectations](#expectations) section, if you are experiencing strange behaviors.

  = render 'interfaces/templates/modal_url'

section.docs-section
  a[href="#modal-load-event"]
    h2#modal-load-event Modal for URL modal:load event
  markdown:
    When loading a modal template from a url, you might need to run initializing
    scripts for libs like select2, autocomplete, or datepicker. You can tie into
    the `modal:load` event hook to run these initializers.  This will fire the
    moment your modal is added to the DOM.

  .row:.col:pre.code-sample-static.language-javascript:code
    | $(document).on('modal:load', function () { /* codez */ });

section.docs-section
  a[href="#components"]
    h2#components Components

  markdown:
    [ components information ]

  .row:.col:pre.code-sample-static.language-markup:code
    = render_source 'interfaces/templates/modal_components'

  = render 'interfaces/templates/modal_components'

